// apps/sample10/driver is used to test the output of the code generated by this file.
// To generate fk_gen.h used in apps/sample10/driver:
// $ ./build/sample10 deps/pinocchio/models/baxter_simple.urdf apps/sample10/fk_gen.h
#include "backend.h"
#include "spatial_algebra.h"
#include "utils.h"

#include "blocks/block_visitor.h"
#include "blocks/c_code_generator.h"
#include "builder/builder_base.h"
#include "builder/builder_context.h"
#include "builder/dyn_var.h"
#include "builder/forward_declarations.h"
#include "builder/static_var.h"
#include "builder/lib/utils.h"

#include "Eigen/Dense"
#include <Eigen/src/Core/IO.h>
#include <Eigen/src/Core/Matrix.h>
#include <string>

const size_t N_X_T = 3;

const double data[N_X_T][36] = {
  {1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0.686,0,1,0,0,-0.686,0,0.06,0,1,0,0,-0.06,0,0,0,1},
  {0.707105,0.707108,0,0,0,0,-0.707108,0.707105,0,0,0,0,0,0,1,0,0,0,-0.0916596,0.0916593,-0.137886,0.707105,0.707108,0,-0.0916593,-0.0916596,0.228434,-0.707108,0.707105,0,0.259027,-0.0640272,0,0,0,1},
  {1,0,0,0,0,0,0,4.89664e-12,-1,0,0,0,0,1,4.89664e-12,0,0,0,0,0.27035,0,1,0,0,-1.32381e-12,0.069,3.37868e-13,0,4.89664e-12,-1,-0.27035,-3.37868e-13,0.069,0,1,4.89664e-12}
};

using builder::dyn_var;
using builder::static_var;

using ctup::Xform;
using ctup::Packet;

static void set_X_T(Xform<double> X_T[]) {
  static_var<int> r;
  static_var<int> c;

  for (static_var<size_t> i = 1; i < N_X_T; i = i+1) {
    Eigen::Matrix<double, 6, 6> pin_X_T(data[i]);

    // setting E
    for (r = 0; r < 3; r = r + 1) {
      for (c = 0; c < 3; c = c + 1) {
        double entry = pin_X_T.coeffRef(c, r);
        if (std::abs(entry) < 1e-5)
          X_T[i].rot.set_entry_to_constant(r, c, 0);
        else {
          X_T[i].rot.set_entry_to_constant(r, c, entry);
        }
      }
    }

    // setting -E*r-cross terms

    for (r = 0; r < 3; r = r + 1) {
      for (c = 0; c < 3; c = c + 1) {
        double entry = pin_X_T.coeffRef(c, r+3);
        X_T[i].minus_E_rcross.set_entry_to_constant(r, c, entry);
      }
    }
  }
}

static dyn_var<ctup::EigenMatrix<double>> fk(dyn_var<builder::eigen_vectorXd_t &> q) {
  Xform<double> X_T[N_X_T];

  static_var<int> r;
  static_var<int> c;

  set_X_T(X_T);

  Packet<double> X_1;
  Packet<double> X_2;

  X1.set_revolute_axis('Z');
  X1.jcalc(q(1));

  X2 = X1 * X_T[1];

  print_Xmat("us X1:", X1);
  print_Xmat("us X_T[1]:", X_T[1]);
  print_Xmat("us X2:", X2);

  dyn_var<ctup::EigenMatrix<double>> final_ans;

  toEigen(final_ans, X2);

  return final_ans;
}

int main(int argc, char* argv[]) {
  const std::string header_filename = (argc <= 1) ? "./fk_gen.h" : argv[1];
  std::cout << header_filename << "\n";

  std::ofstream of(header_filename);
  block::c_code_generator codegen(of);

  of << "// clang-format off\n\n";
  of << "#include \"Eigen/Dense\"\n\n";
  of << "#include <iostream>\n\n";
  of << "namespace ctup_gen {\n\n";

  of << "static void print_string(const char* str) {\n";
  of << "  std::cout << str << \"\\n\";\n";
  of << "}\n\n";

  of << "template<typename Derived>\n";
  of << "static void print_matrix(const Eigen::MatrixBase<Derived>& matrix) {\n";
  of << "  std::cout << matrix << \"\\n\";\n";
  of << "}\n\n";

  builder::builder_context context;

  auto ast = context.extract_function_ast(fk, "fk");
  block::c_code_generator::generate_code(ast, of, 0);

  of << "}\n";
}
