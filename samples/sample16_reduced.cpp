// apps/sample10/driver is used to test the output of the code generated by this file.
// To generate fk_gen.h used in apps/sample10/driver:
// $ ./build/sample10 deps/pinocchio/models/baxter_simple.urdf apps/sample10/fk_gen.h
#include "backend.h"
#include "spatial_algebra.h"
#include "utils.h"

#include "blocks/block_visitor.h"
#include "blocks/c_code_generator.h"
#include "builder/builder_base.h"
#include "builder/builder_context.h"
#include "builder/dyn_var.h"
#include "builder/forward_declarations.h"
#include "builder/static_var.h"
#include "builder/lib/utils.h"

#include <yaml-cpp/yaml.h>

#include "Eigen/Dense"
#include <Eigen/src/Core/IO.h>
#include <Eigen/src/Core/Matrix.h>
#include <string>
#include <vector>


using builder::dyn_var;
using builder::static_var;

//static const char vector_t_name[] = "std::vector";

//template <typename T>
//using vector_t = builder::name<vector_t_name, T>;

template <typename T>
struct vector_t: public builder::custom_type<T> {
	static constexpr const char* type_name = "std::vector";
	typedef T dereference_type;
	dyn_var<void(int)> size = builder::with_name("size");
};

struct Sphere {
    double center_x;
    double center_y;
    double center_z;
    double radius;
};

struct Cylinder {
    double center_x;
    double center_y;
    double center_z;
    double radius;
    double xv;
    double yv;
    double zv;
    double rdv;
    bool z_aligned;
};

struct Box {
    double center_x;
    double center_y;
    double center_z;
    double caxis_1_x;
    double caxis_1_y;
    double caxis_1_z;
    double caxis_1_r;
    double caxis_2_x;
    double caxis_2_y;
    double caxis_2_z;
    double caxis_2_r;
    double caxis_3_x;
    double caxis_3_y;
    double caxis_3_z;
    double caxis_3_r;
    bool xyz_aligned;
};

struct Envir_Objects{
    std::vector<Sphere> speheres;
    std::vector<Cylinder> cylinders;
    std::vector<Box> boxs;
};

static dyn_var<int> Sphere_Environment_Collision(
  const Envir_Objects& obj,
  dyn_var<ctup::BlazeStaticVector<double,16>> ax, dyn_var<ctup::BlazeStaticVector<double,16>> ay, dyn_var<ctup::BlazeStaticVector<double,16>> az, dyn_var<ctup::BlazeStaticVector<double,16>> ar,
  dyn_var<vector_t<ctup::BlazeStaticVector<double,16>>> bx, dyn_var<vector_t<ctup::BlazeStaticVector<double,16>>> by, dyn_var<vector_t<ctup::BlazeStaticVector<double,16>>> bz, dyn_var<vector_t<ctup::BlazeStaticVector<double,16>>> br)
  {
  dyn_var<int> res=false;
  for(static_var<size_t> l=0;l<std::size(obj.speheres);l=l+1){
    const Sphere& sphere=obj.speheres[l];
    dyn_var<ctup::BlazeStaticVector<double,16>> xs = (ax - sphere.center_x);
    dyn_var<ctup::BlazeStaticVector<double,16>> ys = (ay - sphere.center_y);
    dyn_var<ctup::BlazeStaticVector<double,16>> zs = (az - sphere.center_z);

    dyn_var<ctup::BlazeStaticVector<double,16>> sum= xs*xs+ys*ys+zs*zs;
    dyn_var<ctup::BlazeStaticVector<double,16>> rs = ar + sphere.radius;

    sum = sum - rs*rs;

    for(dyn_var<int> j=0;j<16 && res==false;j=j+1){
      if(sum[j]<0.0){
        res=true;
      }
    }
    if(res){
      for(dyn_var<int> i=0;i<bx.size();i=i+1){
        xs = (bx[i] - sphere.center_x);
        ys = (by[i] - sphere.center_y);
        zs = (bz[i] - sphere.center_z);

        sum= xs*xs+ys*ys+zs*zs;
        rs = br(i) + sphere.radius;

        sum = sum - rs*rs;

        for(dyn_var<int> j=0;j<16;j=j+1){
          if(sum[j]<0.0){
            return 1;
          }
        }
      }
      res=false;
    }
  }
  for(static_var<size_t> l=0;l<std::size(obj.cylinders);l=l+1){
    const Cylinder& cylinder=obj.cylinders[l];
    if(cylinder.z_aligned){
      dyn_var<ctup::BlazeStaticVector<double,16>> xs = (ax - cylinder.center_x);
      dyn_var<ctup::BlazeStaticVector<double,16>> ys = (ay - cylinder.center_y);
      dyn_var<ctup::BlazeStaticVector<double,16>> zs = (az - cylinder.center_z);
      dyn_var<ctup::BlazeStaticVector<double,16>> dot= zs*cylinder.zv;
      
      dyn_var<ctup::BlazeStaticVector<double,16>> cdf = ctup::backend::min<double, 16>(ctup::backend::max<double, 16>((dot * cylinder.rdv),1.0),0.0);

      zs = (az - (cylinder.center_z+cylinder.zv*cdf));

      dyn_var<ctup::BlazeStaticVector<double,16>> sum= xs*xs+ys*ys+zs*zs;

      dyn_var<ctup::BlazeStaticVector<double,16>> rs = ar + cylinder.radius;

      sum = sum - rs*rs;

      for(dyn_var<int> j=0;j<16 && res == false;j=j+1){
        if(sum[j]<0.0){
          res=true;
        }
      }

      if(res){
        for(dyn_var<int> i=0;i<bx.size();i=i+1){
          xs = (bx[i] - cylinder.center_x);
          ys = (by[i] - cylinder.center_y);
          zs = (bz[i] - cylinder.center_z);

          cdf = ctup::backend::min<double, 16>(ctup::backend::max<double, 16>((dot * cylinder.rdv),1.0),0.0);
          zs = (az - (cylinder.center_z+cylinder.zv*cdf));

          sum= xs*xs+ys*ys+zs*zs;
          rs = ar + cylinder.radius;
          sum = sum - rs*rs;

          for(dyn_var<int> j=0;j<16;j=j+1){
            if(sum[j]<0.0){
              return 1;
            }
          }
        }
        res=false;
      }
    }
    else{
      std::cout<<"Error not alligned cylinder"<<std::endl;
    }
  }
  for(static_var<size_t> l=0;l<std::size(obj.boxs);l=l+1){
  const Box& box=obj.boxs[l];
    if(box.xyz_aligned){
      dyn_var<ctup::BlazeStaticVector<double,16>> xs = (ax - box.center_x);
      dyn_var<ctup::BlazeStaticVector<double,16>> ys = (ay - box.center_y);
      dyn_var<ctup::BlazeStaticVector<double,16>> zs = (az - box.center_z);

      dyn_var<ctup::BlazeStaticVector<double,16>> a1 = ctup::backend::max<double, 16>((ctup::backend::abs<double, 16>(xs) - box.caxis_1_r),0.0);
      dyn_var<ctup::BlazeStaticVector<double,16>> a2 = ctup::backend::max<double, 16>((ctup::backend::abs<double, 16>(ys) - box.caxis_2_r),0.0);
      dyn_var<ctup::BlazeStaticVector<double,16>> a3 = ctup::backend::max<double, 16>((ctup::backend::abs<double, 16>(zs) - box.caxis_3_r),0.0);

      dyn_var<ctup::BlazeStaticVector<double,16>> sum= a1*a1+a2*a2+a3*a3;

      sum = sum - ar*ar;

      for(dyn_var<int> j=0;j<16 && res==false;j=j+1){
        if(sum[j]<0.0){
          res=true;
        }
      }

      if(res){
        for(dyn_var<int> i=0;i<bx.size();i=i+1){
          xs = (bx[i] - box.center_x);
          ys = (by[i] - box.center_y);
          zs = (bz[i] - box.center_z);

          a1 = ctup::backend::max<double, 16>((ctup::backend::abs<double, 16>(xs) - box.caxis_1_r),0.0);
          a2 = ctup::backend::max<double, 16>((ctup::backend::abs<double, 16>(ys) - box.caxis_2_r),0.0);
          a3 = ctup::backend::max<double, 16>((ctup::backend::abs<double, 16>(zs) - box.caxis_3_r),0.0);

          sum= a1*a1+a2*a2+a3*a3;
          sum = sum - ar*ar;

          for(dyn_var<int> j=0;j<16;j=j+1){
            if(sum[j]<0.0){
              return 1;
            }
          }
        }
        res=false;
      }
    }
    else{
      std::cout<<"Error not alligned box"<<std::endl;
    }
  }
  return 0;
}

//------------------//
//----READ YAML----//
//----------------//

struct Primitive {
    std::string type;
    std::vector<double> dimensions;
};

struct Pose {
    std::vector<double> position;
    std::vector<double> orientation;
};

struct CollisionObject {
    std::string id;
    Primitive primitive;
    Pose pose;
};

static void parseCollisionObjects(const YAML::Node& collisionObjectsNode, std::vector<CollisionObject>& objects) {
    for (const auto& objNode : collisionObjectsNode) {
        CollisionObject obj;
        obj.id = objNode["id"].as<std::string>();
        
        const auto& primitiveNode = objNode["primitives"][0];
        obj.primitive.type = primitiveNode["type"].as<std::string>();
        obj.primitive.dimensions = primitiveNode["dimensions"].as<std::vector<double>>();
        
        const auto& poseNode = objNode["primitive_poses"][0];
        obj.pose.position = poseNode["position"].as<std::vector<double>>();
        obj.pose.orientation = poseNode["orientation"].as<std::vector<double>>();

        objects.push_back(obj);
    }
}
//------------------//
//----READ YAML----//
//----------------//

int main(int argc, char* argv[]) {
    const std::string yaml_filename = argv[1];
    std::cout << yaml_filename << "\n";
    //--------------------------
    //LOAD YAML FILE
    //--------------------------
    YAML::Node root = YAML::LoadFile(yaml_filename);
    // Parse collision objects
    std::vector<CollisionObject> collisionObjects;
    if (root["world"] && root["world"]["collision_objects"]) {
        parseCollisionObjects(root["world"]["collision_objects"], collisionObjects);
    } else {
        std::cerr << "No collision objects found in the YAML file." << std::endl;
        return 1;
    }
    std::vector<Sphere> speheres;
    std::vector<Cylinder> cylinders;
    std::vector<Box> boxs;
    Envir_Objects env_obj;
    for (const auto& obj : collisionObjects) {
        if(obj.primitive.type=="box"){
            Box a;
            a.center_x=obj.pose.position[0];
            a.center_y=obj.pose.position[1];
            a.center_z=obj.pose.position[2];

            a.caxis_1_r=obj.primitive.dimensions[0];
            a.caxis_2_r=obj.primitive.dimensions[1];
            a.caxis_3_r=obj.primitive.dimensions[2];

            if(obj.pose.orientation[0]==0 && obj.pose.orientation[1]==0 && obj.pose.orientation[2]==0 && obj.pose.orientation[3]==1){
                a.caxis_1_x=1;
                a.caxis_1_y=0;
                a.caxis_1_z=0;
                
                a.caxis_2_x=0;
                a.caxis_2_y=1;
                a.caxis_2_z=0;

                a.caxis_3_x=0;
                a.caxis_3_y=0;
                a.caxis_3_z=1;

                a.xyz_aligned=true;
            }
            else{
                std::cout << "  Not alligned ";
                std::cout << std::endl;
                // TO DO
            }

            boxs.push_back(a);
        }
        else if(obj.primitive.type=="cylinder"){
            Cylinder a;
            a.center_x=obj.pose.position[0];
            a.center_y=obj.pose.position[1];
            a.center_z=obj.pose.position[2];

            a.radius=obj.primitive.dimensions[0];
            a.rdv=obj.primitive.dimensions[1];

            if(obj.pose.orientation[0]==0 && obj.pose.orientation[1]==0 && obj.pose.orientation[2]==0 && obj.pose.orientation[3]==1){
                a.z_aligned=true;
            }
            a.xv=obj.pose.orientation[0];
            a.yv=obj.pose.orientation[1];
            a.zv=obj.pose.orientation[2];

            cylinders.push_back(a);
        }
    }
    env_obj.speheres=speheres;
    env_obj.cylinders=cylinders;
    env_obj.boxs=boxs;
    //--------------------------
    //END LOAD YAML FILE
    //--------------------------


    const std::string header_filename = (argc <= 2) ? "./fk_gen.h" : argv[2];
    std::cout << header_filename << "\n";

    std::ofstream of(header_filename);
    block::c_code_generator codegen(of);

    of << "#include \"Eigen/Dense\"\n\n";
    of << "#include <iostream>\n\n";
    of << "namespace ctup_gen {\n\n";

    builder::builder_context context;

    auto ast = context.extract_function_ast(Sphere_Environment_Collision, "Sphere_Environment_Collision", env_obj);
    block::c_code_generator::generate_code(ast, of, 0);

    of << "}\n";
}