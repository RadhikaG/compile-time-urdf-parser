// apps/sample10/driver is used to test the output of the code generated by this file.
// To generate fk_gen.h used in apps/sample10/driver:
// $ ./build/sample10 deps/pinocchio/models/baxter_simple.urdf apps/sample10/fk_gen.h
#include "backend.h"
#include "spatial_algebra.h"
#include "utils.h"

#include "blocks/block_visitor.h"
#include "blocks/c_code_generator.h"
#include "builder/builder_base.h"
#include "builder/builder_context.h"
#include "builder/dyn_var.h"
#include "builder/forward_declarations.h"
#include "Eigen/Dense"
#include "builder/static_var.h"
#include "builder/lib/utils.h"

// ignore unused header warning in IDE, this is needed
#include "pinocchio/multibody/joint/joint-collection.hpp"
#include "pinocchio/multibody/model.hpp"
#include "pinocchio/parsers/urdf.hpp"
#include "assert.h"
#include <memory>
#include <string>

using builder::dyn_var;
using builder::static_var;

using pinocchio::Model;

using ctup::Xform;
using ctup::EigenMatrix;

void set_X_T(Xform<double> X_T[], const Model &model) {
  typedef typename Model::JointIndex JointIndex;
  static_var<JointIndex> i;

  static_var<int> r;
  static_var<int> c;

  for (i = 1; i < (JointIndex)model.njoints; i = i+1) {
    Eigen::Matrix<double, 6, 6> pin_X_T = model.jointPlacements[i];

    // setting E
    for (r = 0; r < 3; r = r + 1) {
      for (c = 0; c < 3; c = c + 1) {
        double entry = pin_X_T.coeffRef(c, r);
        if (std::abs(entry) < 1e-5)
          X_T[i].rot.set_entry_to_constant(r, c, 0);
        else
          X_T[i].rot.set_entry_to_constant(r, c, entry);
      }
    }

    // setting -E*r-cross terms

    for (r = 0; r < 3; r = r + 1) {
      for (c = 0; c < 3; c = c + 1) {
        double entry = pin_X_T.coeffRef(c, r+3);
        X_T[i].minus_E_rcross.set_entry_to_constant(r, c, entry);
      }
    }
  }
}

dyn_var<EigenMatrix<double>> fk(const Model &model, dyn_var<builder::eigen_vectorXd_t &> q) {
  Xform<double> X_T[model.njoints];

  static_var<int> r;
  static_var<int> c;

  set_X_T(X_T, model);

  Xform<double> X1, X2;

  X1.set_revolute_axis('Z');
  X1.jcalc(q(1));

  X2 = X1 * X_T[1];

  print_Xmat("us X1:", X1);
  print_Xmat("us X_T[1]:", X_T[1]);
  print_Xmat("us X2:", X2);

  dyn_var<EigenMatrix<double>> final_ans;
  setEigenMatrixTemplateDims(final_ans, 6, 6);

  toEigen(final_ans, X2);

  return final_ans;
}

int main(int argc, char* argv[]) {
  const std::string urdf_filename = argv[1];
  std::cout << urdf_filename << "\n";

  const std::string header_filename = (argc <= 2) ? "./fk_gen.h" : argv[2];
  std::cout << header_filename << "\n";

  Model model;
  pinocchio::urdf::buildModel(urdf_filename, model);

  std::ofstream of(header_filename);
  block::c_code_generator codegen(of);

  of << "#include \"Eigen/Dense\"\n\n";
  of << "#include <iostream>\n\n";
  of << "namespace ctup_gen {\n\n";

  of << "void print_string(const char* str) {\n";
  of << "  std::cout << str << \"\\n\";\n";
  of << "}\n\n";

  of << "template<typename Derived>\n";
  of << "void print_matrix(const Eigen::MatrixBase<Derived>& matrix) {\n";
  of << "  std::cout << matrix << \"\\n\";\n";
  of << "}\n\n";

  builder::builder_context context;

  auto ast = context.extract_function_ast(fk, "fk", model);
  ast->dump(std::cout, 0);
  block::c_code_generator::generate_code(ast, of, 0);

  of << "}\n";
}

